// All observing classes has to implement itinterface Observer {  update(): void;}class ConcreteObserver implements Observer {  private name: string;  constructor(name: string) {    this.name = name;  }  public update(): void {    console.log('Received new post post!' + this.name);  }}// Observedinterface Subject {  registerObserver(observer: Observer);  unregisterObserver(observer: Observer);  notifyObservers();}// form the class which implements Subject, sometimes it's worth to create singletonclass ConcreteSubject implements Subject {  private observers: Observer[];  // example how to add something extra  private posts: string[];  constructor() {    this.observers = [];  }  registerObserver(observer: Observer) {    this.observers = [...this.observers, observer];  }  unregisterObserver(observer: Observer) {    this.observers = this.observers.filter((obs: Observer) => {      return obs !== observer;    })  }  notifyObservers() {    this.observers.forEach((obs: Observer) => {      obs.update();    })  }  // example how to add something extra  // addPost(post: string) {  //   this.posts = [...this.posts, post];  //   this.notifyObservers(this.posts);  // }}// How to use:const testSubject: ConcreteSubject = new ConcreteSubject();const observer1: ConcreteObserver = new ConcreteObserver('Fred');const observer2: ConcreteObserver = new ConcreteObserver('John');testSubject.registerObserver(observer1);testSubject.registerObserver(observer2);testSubject.notifyObservers();